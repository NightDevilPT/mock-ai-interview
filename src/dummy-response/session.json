{
	"metadata": {
		"title": "Senior Backend Engineer Interview",
		"description": "Comprehensive technical assessment covering Node.js, microservices architecture, database optimization, and AWS cloud services",
		"careerLevel": "SENIOR",
		"experience": "FIVE_TO_TEN_YEARS",
		"domain": "Backend Development",
		"difficulty": "MIXED",
		"questionTypes": [
			"MULTIPLE_CHOICE",
			"CHECKBOX",
			"TEXT",
			"DROPDOWN",
			"RATING",
			"CODING"
		],
		"focusAreas": [
			"Node.js",
			"Microservices",
			"Database Optimization",
			"AWS",
			"DevOps"
		],
		"totalQuestions": 12,
		"totalPoints": 235,
		"estimatedDuration": 1545
	},
	"questions": [
		{
			"id": "q1-http-status-codes",
			"text": "Which HTTP status code indicates that a resource was successfully created?",
			"content": [
				{
					"type": "paragraph",
					"data": {
						"text": "HTTP status codes are three-digit numbers that indicate the result of an HTTP request. Understanding the correct status codes is crucial for building RESTful APIs."
					},
					"order": 0
				}
			],
			"type": "MULTIPLE_CHOICE",
			"category": "Backend Development",
			"difficulty": "EASY",
			"estimatedDuration": 60,
			"points": 10,
			"order": 0,
			"options": [
				"200 OK",
				"201 Created",
				"202 Accepted",
				"204 No Content"
			],
			"constraints": {
				"maxLength": 0,
				"minLength": 0,
				"timeLimit": 120
			},
			"hints": [
				"Think about what happens when a new resource is successfully added to the server"
			],
			"tags": ["HTTP", "Status Codes", "REST API"],
			"createdAt": "2024-01-15T10:00:00Z",
			"updatedAt": "2024-01-15T10:00:00Z"
		},
		{
			"id": "q2-nodejs-async-pattern",
			"text": "Which design pattern is commonly used in Node.js to handle asynchronous operations without blocking the main thread?",
			"content": [
				{
					"type": "paragraph",
					"data": {
						"text": "Node.js is built around handling asynchronous operations efficiently. Understanding its core architecture is essential for building performant applications."
					},
					"order": 0
				},
				{
					"type": "list",
					"data": {
						"items": [
							"Non-blocking I/O operations",
							"Single-threaded event handling",
							"Callback queue management",
							"Efficient resource utilization"
						],
						"style": "unordered"
					},
					"order": 1
				}
			],
			"type": "MULTIPLE_CHOICE",
			"category": "Node.js",
			"difficulty": "MEDIUM",
			"estimatedDuration": 90,
			"points": 15,
			"order": 1,
			"options": [
				"Singleton Pattern",
				"Observer Pattern",
				"Event Loop Pattern",
				"Factory Pattern"
			],
			"constraints": {
				"maxLength": 0,
				"minLength": 0,
				"timeLimit": 180
			},
			"hints": [
				"Think about Node.js's core architecture for handling I/O operations",
				"Consider how Node.js manages concurrent operations without threads"
			],
			"tags": ["Node.js", "Design Patterns", "Asynchronous Programming"],
			"createdAt": "2024-01-15T10:05:00Z",
			"updatedAt": "2024-01-15T10:05:00Z"
		},
		{
			"id": "q3-aws-microservices",
			"text": "Select all the AWS services that are commonly used for building microservices architectures:",
			"content": [
				{
					"type": "paragraph",
					"data": {
						"text": "Microservices architecture requires various supporting services for deployment, communication, and orchestration. AWS provides numerous services that facilitate microservices implementation."
					},
					"order": 0
				},
				{
					"type": "table",
					"data": {
						"headers": [
							"Service Category",
							"AWS Services",
							"Purpose"
						],
						"rows": [
							{
								"cells": [
									"Container Management",
									"ECS, EKS",
									"Orchestration"
								]
							},
							{
								"cells": [
									"Serverless",
									"Lambda",
									"Function execution"
								]
							},
							{
								"cells": [
									"API Management",
									"API Gateway",
									"Request routing"
								]
							},
							{
								"cells": [
									"Workflow",
									"Step Functions",
									"Service coordination"
								]
							}
						]
					},
					"order": 1
				}
			],
			"type": "CHECKBOX",
			"category": "AWS",
			"difficulty": "MEDIUM",
			"estimatedDuration": 120,
			"points": 20,
			"order": 2,
			"options": [
				"Amazon ECS",
				"AWS Lambda",
				"Amazon RDS",
				"Amazon API Gateway",
				"Amazon S3",
				"AWS Step Functions"
			],
			"constraints": {
				"maxLength": 0,
				"minLength": 0,
				"timeLimit": 240
			},
			"hints": [
				"Consider services that help with containerization, serverless computing, API management, and workflow orchestration",
				"Think about which services are specific to compute and orchestration rather than just storage"
			],
			"tags": ["AWS", "Microservices", "Cloud Architecture"],
			"createdAt": "2024-01-15T10:10:00Z",
			"updatedAt": "2024-01-15T10:10:00Z"
		},
		{
			"id": "q4-database-optimization",
			"text": "Which of the following database optimization techniques should be applied for improving query performance? (Select all that apply)",
			"content": [
				{
					"type": "paragraph",
					"data": {
						"text": "Database performance optimization is crucial for scalable applications. Multiple techniques can be employed to improve query execution and overall database efficiency."
					},
					"order": 0
				},
				{
					"type": "code",
					"data": {
						"code": "-- Example of good vs bad queries\n\n-- BAD: Using SELECT *\nSELECT * FROM users WHERE active = 1;\n\n-- GOOD: Selecting specific columns with index\nSELECT id, name, email FROM users \nWHERE active = 1 \nAND created_at > '2023-01-01';",
						"language": "sql"
					},
					"order": 1
				}
			],
			"type": "CHECKBOX",
			"category": "Database Optimization",
			"difficulty": "MEDIUM",
			"estimatedDuration": 150,
			"points": 25,
			"order": 3,
			"options": [
				"Creating appropriate indexes",
				"Query result caching",
				"Database normalization",
				"Connection pooling",
				"Using SELECT *",
				"Partitioning large tables"
			],
			"constraints": {
				"maxLength": 0,
				"minLength": 0,
				"timeLimit": 300
			},
			"hints": [
				"Think about techniques that reduce query execution time and improve resource utilization",
				"Consider what makes queries slower vs faster"
			],
			"tags": ["Database", "Performance", "Optimization"],
			"createdAt": "2024-01-15T10:15:00Z",
			"updatedAt": "2024-01-15T10:15:00Z"
		},
		{
			"id": "q5-microservices-comparison",
			"text": "Describe the advantages and disadvantages of using microservices architecture compared to monolithic architecture. Include considerations for team scalability, deployment complexity, and system reliability.",
			"content": [
				{
					"type": "paragraph",
					"data": {
						"text": "The choice between microservices and monolithic architecture is a fundamental decision that affects development, deployment, and maintenance of software systems."
					},
					"order": 0
				},
				{
					"type": "list",
					"data": {
						"items": [
							"Team autonomy and development speed",
							"Technology stack flexibility",
							"Service independence and fault isolation",
							"Deployment and operational complexity",
							"Inter-service communication challenges",
							"Data consistency and transaction management"
						],
						"style": "unordered"
					},
					"order": 1
				},
				{
					"type": "media",
					"data": {
						"url": "https://example.com/microservices-vs-monolith.png",
						"caption": "Microservices vs Monolithic Architecture Comparison",
						"altText": "Diagram comparing microservices and monolithic architectures"
					},
					"order": 2
				}
			],
			"type": "TEXT",
			"category": "Microservices",
			"difficulty": "HARD",
			"estimatedDuration": 300,
			"points": 35,
			"order": 4,
			"options": [],
			"constraints": {
				"maxLength": 1000,
				"minLength": 200,
				"timeLimit": 600
			},
			"hints": [
				"Consider both technical and organizational aspects",
				"Think about how each architecture affects development teams and operations",
				"Address the specific areas mentioned: team scalability, deployment, and reliability"
			],
			"tags": ["Microservices", "Architecture", "System Design"],
			"createdAt": "2024-01-15T10:20:00Z",
			"updatedAt": "2024-01-15T10:20:00Z"
		},
		{
			"id": "q6-connection-pooling",
			"text": "Explain the concept of connection pooling in database management and why it's important for Node.js applications. Provide an example of how you would implement it.",
			"content": [
				{
					"type": "paragraph",
					"data": {
						"text": "Database connections are expensive resources that need to be managed efficiently in Node.js applications to ensure optimal performance and resource utilization."
					},
					"order": 0
				},
				{
					"type": "code",
					"data": {
						"code": "// Without connection pooling (inefficient)\nconst { Client } = require('pg');\n\nasync function queryUser(id) {\n  const client = new Client(); // New connection every time!\n  await client.connect();\n  const result = await client.query('SELECT * FROM users WHERE id = $1', [id]);\n  await client.end();\n  return result.rows[0];\n}",
						"language": "javascript"
					},
					"order": 1
				}
			],
			"type": "TEXT",
			"category": "Database Optimization",
			"difficulty": "MEDIUM",
			"estimatedDuration": 240,
			"points": 30,
			"order": 5,
			"options": [],
			"constraints": {
				"maxLength": 800,
				"minLength": 150,
				"timeLimit": 480
			},
			"hints": [
				"Consider the overhead of creating new database connections",
				"Think about resource management and application performance",
				"Include practical implementation details"
			],
			"tags": [
				"Database",
				"Connection Pooling",
				"Performance",
				"Node.js"
			],
			"createdAt": "2024-01-15T10:25:00Z",
			"updatedAt": "2024-01-15T10:25:00Z"
		},
		{
			"id": "q7-nodejs-error-handling",
			"text": "What is your preferred approach for handling errors in Node.js applications?",
			"content": [
				{
					"type": "paragraph",
					"data": {
						"text": "Error handling is crucial for building robust Node.js applications. Different approaches have evolved with JavaScript language features."
					},
					"order": 0
				}
			],
			"type": "DROPDOWN",
			"category": "Node.js",
			"difficulty": "EASY",
			"estimatedDuration": 60,
			"points": 10,
			"order": 6,
			"options": [
				"Try-catch blocks with async/await",
				"Promise .catch() methods",
				"Error-first callbacks",
				"Global error handlers only",
				"No specific error handling"
			],
			"constraints": {
				"maxLength": 0,
				"minLength": 0,
				"timeLimit": 120
			},
			"hints": ["Consider modern JavaScript practices and readability"],
			"tags": ["Node.js", "Error Handling", "Best Practices"],
			"createdAt": "2024-01-15T10:30:00Z",
			"updatedAt": "2024-01-15T10:30:00Z"
		},
		{
			"id": "q8-aws-serverless-api",
			"text": "Which AWS service would you primarily use for implementing a serverless API?",
			"content": [
				{
					"type": "paragraph",
					"data": {
						"text": "Serverless architecture eliminates the need to manage servers, allowing developers to focus on code while AWS handles the infrastructure automatically."
					},
					"order": 0
				}
			],
			"type": "DROPDOWN",
			"category": "AWS",
			"difficulty": "EASY",
			"estimatedDuration": 45,
			"points": 10,
			"order": 7,
			"options": [
				"Amazon EC2",
				"AWS Lambda",
				"Amazon ECS",
				"AWS Batch",
				"Amazon Lightsail"
			],
			"constraints": {
				"maxLength": 0,
				"minLength": 0,
				"timeLimit": 90
			},
			"hints": [
				"Think about services that don't require server management"
			],
			"tags": ["AWS", "Serverless", "API"],
			"createdAt": "2024-01-15T10:35:00Z",
			"updatedAt": "2024-01-15T10:35:00Z"
		},
		{
			"id": "q9-docker-experience",
			"text": "Rate your experience level with Docker containerization (1 = Beginner, 5 = Expert):",
			"content": [
				{
					"type": "paragraph",
					"data": {
						"text": "Docker containerization is essential for modern application deployment and development workflows. Please provide an honest assessment of your experience level."
					},
					"order": 0
				}
			],
			"type": "RATING",
			"category": "DevOps",
			"difficulty": "EASY",
			"estimatedDuration": 30,
			"points": 5,
			"order": 8,
			"options": [],
			"constraints": {
				"maxLength": 0,
				"minLength": 0,
				"timeLimit": 60
			},
			"hints": [],
			"tags": ["Docker", "Containerization", "Self-Assessment"],
			"createdAt": "2024-01-15T10:40:00Z",
			"updatedAt": "2024-01-15T10:40:00Z"
		},
		{
			"id": "q10-microservices-confidence",
			"text": "How would you rate your confidence in designing scalable microservices architectures (1 = Not confident, 5 = Very confident)?",
			"content": [
				{
					"type": "paragraph",
					"data": {
						"text": "Designing scalable microservices requires understanding of distributed systems, service communication, data management, and operational complexity."
					},
					"order": 0
				}
			],
			"type": "RATING",
			"category": "Microservices",
			"difficulty": "EASY",
			"estimatedDuration": 30,
			"points": 5,
			"order": 9,
			"options": [],
			"constraints": {
				"maxLength": 0,
				"minLength": 0,
				"timeLimit": 60
			},
			"hints": [],
			"tags": ["Microservices", "Architecture", "Self-Assessment"],
			"createdAt": "2024-01-15T10:45:00Z",
			"updatedAt": "2024-01-15T10:45:00Z"
		},
		{
			"id": "q11-mongodb-query-coding",
			"text": "Implement a Node.js function that connects to a MongoDB database and retrieves all users where the age is greater than 25. Use async/await and proper error handling.",
			"content": [
				{
					"type": "paragraph",
					"data": {
						"text": "Create a function called <code>getUsersAbove25</code> that connects to MongoDB using the native MongoDB driver, queries the database, and returns users matching the age criteria with proper error handling."
					},
					"order": 0
				},
				{
					"type": "list",
					"data": {
						"items": [
							"Use the MongoDB native driver (mongodb package)",
							"Implement proper connection management",
							"Use async/await for asynchronous operations",
							"Include comprehensive error handling",
							"Close database connections appropriately"
						],
						"style": "ordered"
					},
					"order": 1
				},
				{
					"type": "code",
					"data": {
						"code": "const { MongoClient } = require('mongodb');\n\n// Database connection string\nconst connectionString = 'mongodb://localhost:27017/userdb';\n\nasync function getUsersAbove25() {\n  // Your implementation here\n  // 1. Connect to MongoDB\n  // 2. Access the users collection\n  // 3. Query for users with age > 25\n  // 4. Handle errors appropriately\n  // 5. Close the connection\n  // 6. Return the results\n}\n\n// Usage example\ngetUsersAbove25()\n  .then(users => console.log('Found users:', users))\n  .catch(err => console.error('Error:', err));",
						"language": "javascript"
					},
					"order": 2
				},
				{
					"type": "paragraph",
					"data": {
						"text": "<strong>Expected MongoDB collection structure:</strong> The users collection contains documents with fields like <code>name</code>, <code>age</code>, <code>email</code>, etc."
					},
					"order": 3
				}
			],
			"type": "CODING",
			"category": "Database",
			"difficulty": "MEDIUM",
			"estimatedDuration": 420,
			"points": 40,
			"order": 10,
			"options": [],
			"constraints": {
				"maxLength": 1500,
				"minLength": 100,
				"timeLimit": 600
			},
			"hints": [
				"Use MongoClient.connect() to establish connection",
				"Remember to close the database connection",
				"Use find() method with appropriate query filter {age: {$gt: 25}}",
				"Convert cursor to array using toArray()"
			],
			"tags": ["Node.js", "MongoDB", "Database", "Async/Await"],
			"createdAt": "2024-01-15T10:50:00Z",
			"updatedAt": "2024-01-15T10:50:00Z"
		},
		{
			"id": "q12-express-middleware-coding",
			"text": "Create a simple Express.js middleware function that logs the request method, URL, and timestamp for each incoming request. The middleware should also add a unique request ID to each request.",
			"content": [
				{
					"type": "paragraph",
					"data": {
						"text": "Implement a logging middleware function that can be used with <code>app.use()</code>. The middleware should generate a unique ID for each request and log essential request information."
					},
					"order": 0
				},
				{
					"type": "list",
					"data": {
						"items": [
							"Generate a unique request ID for each request",
							"Attach the request ID to the req object",
							"Log the HTTP method, URL, timestamp, and request ID",
							"Call next() to pass control to the next middleware",
							"Use proper date formatting for timestamps"
						],
						"style": "ordered"
					},
					"order": 1
				},
				{
					"type": "code",
					"data": {
						"code": "const express = require('express');\nconst crypto = require('crypto');\nconst app = express();\n\n// Implement your middleware function here\nfunction loggingMiddleware(req, res, next) {\n  // TODO: Generate unique request ID\n  // TODO: Attach ID to req.requestId\n  // TODO: Log method, URL, timestamp, and ID\n  // TODO: Call next() to continue\n}\n\n// Use the middleware\napp.use(loggingMiddleware);\n\n// Example routes for testing\napp.get('/', (req, res) => {\n  res.send(`Hello! Request ID: ${req.requestId}`);\n});\n\napp.post('/users', (req, res) => {\n  res.json({ message: 'User created', requestId: req.requestId });\n});\n\napp.listen(3000, () => console.log('Server running on port 3000'));",
						"language": "javascript"
					},
					"order": 2
				},
				{
					"type": "paragraph",
					"data": {
						"text": "<strong>Expected output format:</strong> <code>[2024-01-15T10:30:45.123Z] GET / - ID: abc123def456</code>"
					},
					"order": 3
				}
			],
			"type": "CODING",
			"category": "Node.js",
			"difficulty": "EASY",
			"estimatedDuration": 300,
			"points": 25,
			"order": 11,
			"options": [],
			"constraints": {
				"maxLength": 1000,
				"minLength": 80,
				"timeLimit": 450
			},
			"hints": [
				"Use crypto.randomUUID() or Math.random() for generating unique IDs",
				"Don't forget to call next() to pass control to the next middleware",
				"Consider using new Date().toISOString() for timestamps",
				"Use console.log for logging with a clear format"
			],
			"tags": ["Express.js", "Middleware", "Logging", "Node.js"],
			"createdAt": "2024-01-15T10:55:00Z",
			"updatedAt": "2024-01-15T10:55:00Z"
		}
	]
}
